<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Grand Element Radio</title>
<style>
  :root{
    --glass: rgba(255,255,255,.08);
    --glass-strong: rgba(255,255,255,.12);
    --fg:#e7ecff; --muted:#9db0d7; --accent:#4aa3ff; --bg:#0b0f18;
    --btn-h:42px; --radius:14px;
  }
  html,body{height:100%}
  body{
    margin:0; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--fg); background:#000; overflow-x:hidden;
  }

  /* Background layer */
  #bg, #bg-fade{
    position:fixed; inset:0; object-fit:cover; width:100%; height:100%;
    filter:brightness(.9) saturate(1.05);
  }
  #bg-fade{ opacity:0; transition:opacity .7s ease; }
  .fade-on { opacity:1 !important; }

  /* Top logo */
  .logo { width:160px; height:160px; margin:28px auto 8px; display:block; border-radius:50%; box-shadow:0 10px 40px rgba(0,0,0,.45)}
  main{ position:relative; z-index:2; max-width:840px; margin:0 auto; padding:0 16px 60px; text-align:center;}

  h1{font-size:40px; margin:.2rem 0 .2rem; letter-spacing:.6px}
  p.sub{margin:0 0 .9rem; color:var(--muted)}
  .support-note{margin:18px 0 4px; color:var(--muted)}

  /* Glass card for controls */
  .card{
    margin:18px auto 16px; padding:18px 16px; max-width:760px;
    background:var(--glass); backdrop-filter: blur(9px);
    border-radius:20px; border:1px solid rgba(255,255,255,.06);
  }
  /* Remove the “extra box” during fade-out: card becomes transparent & clicks-through */
  .card.is-hidden{ background:transparent; border-color:transparent; pointer-events:none }

  /* Buttons */
  .row{display:flex; gap:10px; justify-content:center; flex-wrap:wrap}
  button{
    height:var(--btn-h); padding:0 16px; border-radius:var(--radius);
    border:1px solid rgba(255,255,255,.08);
    background:var(--glass-strong); color:var(--fg);
    font-weight:600; letter-spacing:.2px; cursor:pointer;
    transition:transform .04s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
  }
  button:hover{ box-shadow:0 6px 22px rgba(0,0,0,.32) inset }
  .on{ background:var(--accent); color:#001a33; border-color:transparent }
  .pill{ border-radius:999px }
  .tiny{ height:34px; padding:0 12px; font-size:.92rem }

  /* Track + progress */
  #now{ font-size:1.05rem; margin:8px auto 12px; color:#fff; min-height:1.2em; }
  progress{ width:100%; height:8px; border-radius:999px; overflow:hidden }
  progress::-webkit-progress-bar{ background:rgba(255,255,255,.12) }
  progress::-webkit-progress-value{ background:var(--accent) }

  /* Offline card */
  .muted{ color:var(--muted) }
  .meter{ height:8px; border-radius:999px; background:rgba(255,255,255,.12); overflow:hidden }
  .meter > span{ display:block; height:100%; background:var(--accent); width:0% }

  /* Bandcamp button */
  .bandcamp{
    display:inline-block; margin-top:8px; padding:12px 18px; border-radius:12px;
    background:#ff9f45; color:#2b1700; font-weight:800; text-decoration:none;
    box-shadow:0 8px 30px rgba(0,0,0,.35)
  }

  /* Small screens */
  @media (max-width:560px){
    .logo{ width:132px; height:132px }
    h1{ font-size:32px }
  }
</style>
</head>
<body>
<img id="bg" alt="" />
<img id="bg-fade" alt="" />

<main>
  <img class="logo" src="../img/ge-blue.jpg" alt="Grand Element" onerror="this.style.display='none'">
  <h1>Grand Element Radio</h1>
  <p class="sub">Music created to help set your soul free. Enjoy!!<br/>Refresh the page for a new experience.</p>

  <div id="playerCard" class="card">
    <div class="row" style="margin-bottom:10px">
      <button id="prevBtn" class="pill tiny">Prev</button>
      <button id="nextBtn" class="pill tiny">Next</button>
      <button id="shuffleBtn" class="pill on">Shuffle</button>
      <button id="albumBtn" class="pill">Album order</button>
    </div>

    <div id="now"></div>
    <audio id="audio" preload="auto" crossorigin="anonymous"></audio>
    <progress id="bar" max="1" value="0"></progress>
    <div class="row" style="gap:6px; margin-top:8px">
      <button id="playBtn" class="pill tiny">▶︎</button>
      <span id="time" class="muted tiny" style="line-height:34px"></span>
      <input id="vol" type="range" min="0" max="1" step="0.01" value="1" style="width:180px" />
    </div>

    <div id="err" class="muted" style="margin-top:10px; min-height:1.2em"></div>
  </div>

  <!-- Offline -->
  <div class="card" id="offlineCard">
    <h3 style="margin:0 0 6px">Offline Mode</h3>
    <div class="row" style="margin-bottom:8px">
      <button id="offlineBtn" class="pill tiny">Turn Offline ON</button>
    </div>
    <div class="muted" style="margin:6px 0 8px">Offline caching: <span id="cacheCount">0 / 0 (0%)</span></div>
    <div class="meter"><span id="cacheMeter"></span></div>
    <div class="muted" style="margin-top:8px">Tap to save music for offline use…</div>
  </div>

  <p class="support-note">If you’d like to support the project, you can purchase the music below.</p>
  <a class="bandcamp" href="https://grandelement.bandcamp.com" target="_blank" rel="noopener">Buy on Bandcamp</a>
</main>

<script>
/* ========= CONFIG (keep these if you move folders) ========= */
const GITHUB_OWNER = 'grandelement';
const GITHUB_REPO  = 'grandelement.github.io';
const BASE_DIR     = 'radio';
const MUSIC_DIR    = `${BASE_DIR}/music`;
const IMG_DIR      = `${BASE_DIR}/img`;

/* Permanent album release order (folder names must match exactly) */
const ALBUMS_IN_ORDER = [
  'Grand Element - 2005 - Fundamental Groove',
  'Grand Element - 2006 - Trio',
  'Grand Element - 2007 - Live',
  'Grand Element - 2008 - Sessions I',
  'Grand Element - 2009 - Sessions II',
  'Grand Element - 2010 - Intergy',
  'Grand Element - 2011 - Love',
  'Grand Element - 2017 - Soul',
  'Grand Element - 2021 - Spirit',
  'Grand Element - 2024 - Fire',
  'Grand Element - Singles'
];

/* ========= Helpers ========= */
const $ = sel => document.querySelector(sel);
const fmtTime = s => {
  if (!isFinite(s) || s<0) return '0:00';
  const m = Math.floor(s/60), ss = Math.floor(s%60).toString().padStart(2,'0');
  return `${m}:${ss}`;
};

/* Backgrounds: cycle through whatever is in /img using GitHub API */
async function listDir(path){
  const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${encodeURIComponent(path)}`;
  const res = await fetch(url, {headers:{'Accept':'application/vnd.github+json'}});
  if(!res.ok) throw new Error(`GitHub list failed: ${path}`);
  return res.json();
}

async function loadBackgrounds(){
  try{
    const items = await listDir(IMG_DIR);
    const files = items.filter(x => /\.(gif|jpg|jpeg|png|webp)$/i.test(x.name)).map(x => x.path.replace(`${BASE_DIR}/`,'../'));
    if(!files.length) return;
    let idx = Math.floor(Math.random()*files.length);
    const bg = $('#bg'), fade = $('#bg-fade');
    const switchBg = () => {
      fade.src = files[idx];
      fade.onload = ()=>{
        $('#playerCard').classList.add('is-hidden');    // hide glass box during crossfade
        fade.classList.add('fade-on');
        setTimeout(()=>{
          bg.src = fade.src;
          fade.classList.remove('fade-on');
          $('#playerCard').classList.remove('is-hidden');
        }, 700);
      };
      idx = (idx+1)%files.length;
    };
    // initial & rotate every 30s
    bg.src = files[idx]; idx=(idx+1)%files.length;
    setInterval(switchBg, 30000);
  }catch(e){ console.warn('Backgrounds error', e); }
}

/* Music discovery (no playlists): list folders in release order, then *.mp3 inside each */
async function discoverTracks(){
  const tracks = [];
  const folders = await listDir(MUSIC_DIR);
  // map for quick lookup
  const hasFolder = new Set(folders.filter(f=>f.type==='dir').map(f=>f.name));
  for(const folder of ALBUMS_IN_ORDER){
    if(!hasFolder.has(folder)) continue;
    try{
      const files = await listDir(`${MUSIC_DIR}/${folder}`);
      const mp3s = files.filter(x=>/\.mp3$/i.test(x.name));
      mp3s.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:'base'}));
      for(const f of mp3s){
        const url = '../' + f.path.replace(`${BASE_DIR}/`,''); // relative for Pages
        const display = makeDisplayName(folder, f.name);
        tracks.push({url, album:folder, name:display});
      }
    }catch(e){ console.warn('Folder read failed', folder, e); }
  }
  if(!tracks.length) throw new Error('No MP3s found');
  return tracks;
}

/* Display naming: "Track Title · Album" (you asked for the dot before album name) */
function makeDisplayName(albumFolder, fileName){
  // album text = the last " - Title" token in folder name
  const albumPretty = albumFolder.split(' - ').slice(-1)[0];
  // strip extension + replace underscores with spaces; drop leading album keyword pieces
  const base = fileName.replace(/\.mp3$/i,'').replace(/[_]+/g,' ').replace(/\s{2,}/g,' ').trim();
  // If there's a number chunk like "_02_", try to grab the trailing title part
  const parts = base.split(/\s*-\s*|\s{2,}/).slice(-1);
  let title = base;
  const m = base.match(/\d{1,2}[_\s.-]+(.+)$/);
  if (m && m[1]) title = m[1].trim();
  // Final style
  return `${title} · ${albumPretty}`;
}

/* ========= Player ========== */
const audio = $('#audio');
const bar   = $('#bar');
const time  = $('#time');
const nowEl = $('#now');
const errEl = $('#err');
let queue = [];         // [{url, name, album}]
let mode  = 'shuffle';  // 'shuffle' or 'album'
let idx   = -1;
let userInteracted = false;

function pickNext(fromButton=false){
  if(queue.length===0) return -1;
  if(mode==='shuffle'){
    // On shuffle switch, do not interrupt: if user pressed the Shuffle/Album buttons,
    // we only change the *future* order. Current song keeps playing.
    let n;
    do { n = Math.floor(Math.random()*queue.length); } while (queue.length>1 && n===idx);
    return n;
  }else{ // album order
    return (idx+1) % queue.length;
  }
}

async function startPlayback(i){
  if(i<0) return;
  idx = i;
  const track = queue[idx];
  nowEl.textContent = track.name;
  audio.src = track.url;
  audio.play().catch(()=>{/* will start on first gesture */});
}

function nextTrack(){ startPlayback(pickNext(true)); }
function prevTrack(){
  if(mode==='album'){ idx = (idx-1+queue.length)%queue.length; startPlayback(idx); }
  else { startPlayback(pickNext(true)); }
}

/* Progress + MediaSession */
audio.addEventListener('timeupdate', ()=>{
  if(audio.duration){ bar.value = audio.currentTime / audio.duration; }
  time.textContent = `${fmtTime(audio.currentTime)} / ${fmtTime(audio.duration||0)}`;
});
audio.addEventListener('ended', nextTrack);
if('mediaSession' in navigator){
  navigator.mediaSession.setActionHandler('previoustrack', prevTrack);
  navigator.mediaSession.setActionHandler('nexttrack', nextTrack);
  navigator.mediaSession.setActionHandler('play', ()=>audio.play());
  navigator.mediaSession.setActionHandler('pause', ()=>audio.pause());
}

/* Buttons */
$('#playBtn').onclick = async ()=>{
  userInteracted = true;
  if(audio.paused) await audio.play(); else audio.pause();
};
$('#prevBtn').onclick = ()=>{ userInteracted = true; prevTrack(); };
$('#nextBtn').onclick = ()=>{ userInteracted = true; nextTrack(); };

$('#shuffleBtn').onclick = ()=>{
  mode='shuffle';
  $('#shuffleBtn').classList.add('on');
  $('#albumBtn').classList.remove('on');
  // Do not stop the current track; new mode applies on next.
};
$('#albumBtn').onclick = ()=>{
  mode='album';
  $('#albumBtn').classList.add('on');
  $('#shuffleBtn').classList.remove('on');
  // Do not stop the current track.
};

$('#vol').addEventListener('input', e=> audio.volume = +e.target.value);

/* Autoplay policy: try on load; if blocked on mobile, first tap anywhere enables it */
document.addEventListener('pointerdown', ()=>{ if(!userInteracted){ userInteracted=true; audio.play().catch(()=>{}); }}, {once:true});

/* ========= Offline (service worker assumed at /radio/service-worker.js) ========= */
async function setupSW(){
  if(!('serviceWorker' in navigator)) return;
  try{
    await navigator.serviceWorker.register('./service-worker.js', {scope:'./'});
  }catch(e){ console.warn('SW register failed', e); }
}
const offlineBtn = $('#offlineBtn');
let caching = false;
offlineBtn.onclick = async ()=>{
  if(caching) return;
  caching = true;
  offlineBtn.textContent = 'Caching…';
  try{
    const reg = await navigator.serviceWorker.ready;
    reg.active && reg.active.postMessage({type:'CACHE_TRACKS', tracks: queue.map(t=>t.url)});
  }catch(e){ console.warn(e); }
  setTimeout(()=>{ offlineBtn.textContent = 'Turn Offline ON'; caching=false; }, 800);
};

/* ======== Init ======== */
(async function init(){
  try{
    setupSW();
    await loadBackgrounds();

    errEl.textContent = 'Loading…';
    queue = await discoverTracks();
    errEl.textContent = '';

    // Start with Shuffle, no interruption on mode toggle
    mode='shuffle';
    const first = pickNext();
    await startPlayback(first);

    // Try autoplay immediately; if blocked, first tap will start it.
    audio.play().catch(()=>{/* ignored, handled by first gesture */});
  }catch(e){
    console.error(e);
    errEl.textContent = 'Error loading player';
  }
})();
</script>
</body>
</html>
