<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Grand Element Radio</title>
<style>
  :root{--fg:#eaf6ff;--accent:#5ec5ff;--accent2:#ff6a00}
  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0; min-height:100vh; color:var(--fg);
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    background:#000; overflow-x:hidden;
  }
  /* fixed wallpaper */
  body::before{
    content:""; position:fixed; inset:0; z-index:-2;
    background:#000 center/cover no-repeat;
    background-image:var(--bg-img, none);
    transform:translateZ(0); will-change:transform; pointer-events:none;
  }

  .wrap{margin:auto; width:min(980px,94vw); padding:28px; text-align:center}
  .logo{width:min(260px,60vw); height:auto; border-radius:50%;
        filter:drop-shadow(0 0 24px rgba(94,197,255,.55)); margin:6px 0 12px}
  h1{margin:8px 0 4px; font-weight:800; letter-spacing:.3px}
  p.help{opacity:.92; margin:2px 0 8px}

  .panel,.offline{
    background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.10); border-radius:16px; padding:16px 14px;
    box-shadow:0 10px 30px rgba(0,0,0,.45); backdrop-filter:blur(2px);
    transition:opacity .35s ease;
  }
  .controls{display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:8px 0 12px}
  .btn{
    appearance:none; border:1px solid rgba(255,255,255,.12); padding:10px 14px; border-radius:12px;
    background:#141d2b; color:#eaf6ff; cursor:pointer; font-weight:800;
  }
  .btn:hover{background:#1b2537}
  .btn.on{background:var(--accent); color:#03111b; border-color:transparent}

  audio{width:100%; margin-top:6px; transform:scale(1.12); transform-origin:center top}
  .subtle{opacity:.85; font-size:.95rem; margin-top:8px}
  .err{color:#ff8a8a}

  .offline{margin-top:18px}
  .bar{height:8px; background:#0e1624; border-radius:12px; overflow:hidden; margin:8px auto 0; width:min(540px,92%)}
  .bar>span{display:block; height:100%; width:0%; background:var(--accent); transition:width .2s}

  a.buy{display:inline-block; padding:10px 18px; margin-top:16px; background:var(--accent2); color:#fff;
        text-decoration:none; border-radius:10px; font-weight:800; box-shadow:0 6px 16px rgba(255,106,0,.25)}
  a.buy:hover{filter:brightness(1.05)}

  /* screensaver fade (10s idle) */
  .chrome{transition:opacity .35s ease}
  .fade .chrome{opacity:0}
  /* NEW: fully hide glass panels so no faint box remains */
  .fade .panel, .fade .offline{
    opacity:0 !important; background:transparent !important;
    border-color:transparent !important; box-shadow:none !important;
  }
</style>
</head>
<body>
  <div class="wrap chrome">
    <img src="img/logo.png" alt="Grand Element" class="logo" />
    <h1 class="chrome">Grand Element Radio</h1>
    <p class="help chrome">Music created to help set your soul free. Enjoy!!</p>
    <p class="help chrome">Refresh the page for a new experience.</p>

    <div class="panel chrome">
      <div id="title" style="font-weight:800; margin:6px 0 10px">Loading…</div>
      <div class="controls">
        <button class="btn" id="prevBtn">Prev</button>
        <button class="btn" id="nextBtn">Next</button>
        <button class="btn on" id="shuffleBtn">Shuffle</button>
        <button class="btn" id="albumBtn">Album order</button>
      </div>
      <audio id="player" controls preload="none" playsinline></audio>
      <div id="msg" class="subtle"></div>
    </div>

    <div class="offline chrome">
      <div style="font-weight:800; margin-bottom:8px">Offline Mode</div>
      <button class="btn" id="offlineBtn">Turn Offline ON</button>
      <div class="subtle" id="progressText">Offline caching: 0 / 0 (0%)</div>
      <div class="bar"><span id="progressBar"></span></div>
      <div class="subtle" style="margin-top:8px">Tap to save music for offline use…</div>
    </div>

    <p class="help chrome" style="margin-top:14px">
      If you’d like to support the project, you can purchase the music below.
    </p>
    <a class="buy chrome" href="https://grandelement.bandcamp.com" target="_blank" rel="noopener">Buy on Bandcamp</a>
  </div>

<script>
/* ---------------- Backgrounds (random per refresh) ---------------- */
fetch('backgrounds.json',{cache:'no-store'})
  .then(r=>r.ok?r.json():[]).then(list=>{
    if(Array.isArray(list)&&list.length){
      const pick=list[Math.floor(Math.random()*list.length)];
      document.body.style.setProperty('--bg-img','url("'+pick+'")');
    }
  }).catch(()=>{});

/* ---------------- Elements ---------------- */
const audio = document.getElementById('player');
const titleEl = document.getElementById('title');
const msgEl   = document.getElementById('msg');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const shufBtn = document.getElementById('shuffleBtn');
const albBtn  = document.getElementById('albumBtn');

/* ---------------- Library & ordering ---------------- */
let LIB=[], ORDER=[], IDX=0, shuffleOn=true;

/* Title parsing based on folder layout: music/<AlbumFolder>/<TrackFile>.mp3 */
function fmtTitle(path){
  const parts = path.split('/');
  const albumFull = parts.length>=3 ? parts[parts.length-2] : '';
  const album = albumFull.replace(/^Grand Element - \d{4} - /,'').trim();
  const base = parts[parts.length-1].replace(/\.[^.]+$/,'');
  // optional NN_ prefix (02_Title) or Album_02_Title
  const m = base.match(/(?:^|[_\-. ])(\d{2})[_\-. ]+(.+)$/);
  const trackNum = m ? m[1] : null;
  const song = (m ? m[2] : base)
                .replace(/[_\-]+/g,' ')
                .replace(/ +/g,' ')
                .replace(/\s*=\s*/g,' = ')
                .trim();
  return {album, song, trackNum};
}
function setShuffleTitle(p){ const {album,song}=fmtTitle(p); titleEl.textContent=`${album} • ${song}`; }
function setAlbumTitle(p){ const {album,song,trackNum}=fmtTitle(p); titleEl.textContent=`${album} • ${trackNum?trackNum+' • ':''}${song}`; }

/* Build order but keep current song/time; no src swap unless needed */
function buildOrder(keepSrc){
  const cur = keepSrc || audio.currentSrc || '';
  if(shuffleOn){
    ORDER = LIB.slice();
    for(let i=ORDER.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [ORDER[i],ORDER[j]]=[ORDER[j],ORDER[i]];}
  }else{
    ORDER = LIB.slice(); // album sequence is whatever your TXT lists
  }
  const keep = ORDER.findIndex(p=>cur.includes(p));
  IDX = keep>=0 ? keep : 0;
}

/* Load at index without interrupt if it's already that src */
function loadAt(i, keepTime=true){
  if(!ORDER.length) return;
  IDX = (i+ORDER.length)%ORDER.length;
  const src = ORDER[IDX];
  const was = audio.src;
  const label = shuffleOn ? setShuffleTitle : setAlbumTitle;

  if(!was || !was.includes(src)){
    const t = keepTime ? audio.currentTime : 0;
    audio.src = src + '?v=' + Date.now();
    label(src);
    audio.addEventListener('loadedmetadata', function once(){
      audio.removeEventListener('loadedmetadata', once);
      if(keepTime && t>0 && t<audio.duration) audio.currentTime = t;
      nudgeAutoplay(); // keep rolling
    });
  }else{
    label(src); // just update label
  }
}

/* Discover library from RADIO_TRACK_ORDER.txt (one path per line) */
async function getLibrary(){
  const r = await fetch('RADIO_TRACK_ORDER.txt',{cache:'no-store'});
  if(!r.ok) throw new Error('RADIO_TRACK_ORDER.txt not found');
  const txt = await r.text();
  const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  return lines;
}

/* ---------------- Boot ---------------- */
async function boot(){
  try{
    LIB = await getLibrary();
    buildOrder();
    loadAt(IDX,false);

    audio.addEventListener('ended', ()=>loadAt(IDX+1,false));
    nextBtn.addEventListener('click', ()=>loadAt(IDX+1,true));
    prevBtn.addEventListener('click', ()=>loadAt(IDX-1,true));

    shufBtn.addEventListener('click', ()=>{
      if(!shuffleOn){ shuffleOn=true; shufBtn.classList.add('on'); albBtn.classList.remove('on');
        const cur=ORDER[IDX]; buildOrder(cur); loadAt(IDX,true);
      }
    });
    albBtn.addEventListener('click', ()=>{
      if(shuffleOn){ shuffleOn=false; albBtn.classList.add('on'); shufBtn.classList.remove('on');
        const cur=ORDER[IDX]; buildOrder(cur); loadAt(IDX,true);
      }
    });

    // Media Session integration
    if('mediaSession' in navigator){
      const setMeta = (src)=>{const {album,song}=fmtTitle(src);navigator.mediaSession.metadata=new MediaMetadata({title:song,artist:'Grand Element',album});};
      audio.addEventListener('playing',()=>{if(ORDER[IDX]) setMeta(ORDER[IDX]);});
      try{navigator.mediaSession.setActionHandler('previoustrack',()=>loadAt(IDX-1,false))}catch{}
      try{navigator.mediaSession.setActionHandler('nexttrack',()=>loadAt(IDX+1,false))}catch{}
      try{navigator.mediaSession.setActionHandler('play',()=>nudgeAutoplay())}catch{}
      try{navigator.mediaSession.setActionHandler('pause',()=>audio.pause())}catch{}
    }

    msgEl.textContent="";
  }catch(e){
    titleEl.textContent="Error loading player";
    msgEl.className="subtle err";
    msgEl.textContent=e.message;
  }
}
boot();

/* ---------------- Autoplay nudge (reliable, iOS-safe) ---------------- */
audio.autoplay = true;
async function nudgeAutoplay(){
  try{ if(audio.paused) await audio.play(); }
  catch{
    const once = async ()=>{
      try{ if(audio.paused) await audio.play(); }
      finally{
        document.removeEventListener('pointerdown', once, {capture:true});
        document.removeEventListener('keydown',     once, {capture:true});
      }
    };
    document.addEventListener('pointerdown', once, {capture:true, once:true});
    document.addEventListener('keydown',     once, {capture:true, once:true});
  }
}
window.addEventListener('load', ()=>nudgeAutoplay(), {once:true});
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') nudgeAutoplay(); });

/* ---------------- Offline (with your existing service-worker.js) ---------------- */
const offlineBtn=document.getElementById('offlineBtn');
const bar=document.getElementById('progressBar');
const ptxt=document.getElementById('progressText');

if('serviceWorker' in navigator){ navigator.serviceWorker.register('./service-worker.js'); }
function postSW(msg){ if(navigator.serviceWorker?.controller){ navigator.serviceWorker.controller.postMessage(msg); } }

navigator.serviceWorker?.addEventListener('message',(e)=>{
  const {type,payload}=e.data||{};
  if(type==='CACHE_PROGRESS'){
    const {done,total}=payload; const pct=total?Math.round(done/total*100):0;
    ptxt.textContent=`Offline caching: ${done} / ${total} (${pct}%)`; bar.style.width=pct+'%';
    if(total && done===total) offlineBtn.classList.add('on');
  }
});
offlineBtn.addEventListener('click',()=>{
  if(!ORDER.length) return;
  if(!offlineBtn.classList.contains('on')){
    offlineBtn.classList.add('on'); offlineBtn.textContent='Offline ON — Tap to turn OFF';
    ptxt.textContent='Preparing offline list…'; postSW({type:'CACHE_LIST',payload:{list:ORDER.slice()}});
  }else{
    const ok=confirm('Turn OFF offline mode and remove cached files?'); if(!ok) return;
    offlineBtn.classList.remove('on'); offlineBtn.textContent='Turn Offline ON';
    bar.style.width='0%'; ptxt.textContent='Offline caching: 0 / 0 (0%)'; postSW({type:'CLEAR_OFFLINE'});
  }
});

/* ---------------- Screensaver fade (10s idle) ---------------- */
let fadeTimer=null;
function bump(){ clearTimeout(fadeTimer); document.body.classList.remove('fade'); fadeTimer=setTimeout(()=>document.body.classList.add('fade'),10000); }
['mousemove','pointerdown','keydown','touchstart','wheel'].forEach(ev=>addEventListener(ev,bump,{passive:true}));
bump();
</script>
</body>
</html>
